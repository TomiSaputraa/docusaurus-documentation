"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1037],{9330:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>t,metadata:()=>l,toc:()=>o});var r=a(4848),i=a(8453);const t={sidebar_position:3},s="Belajar React",l={id:"react/react",title:"Belajar React",description:"Link Github",source:"@site/docs/react/react.md",sourceDirName:"react",slug:"/react/",permalink:"/docusaurus-documentation/id/docs/react/",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/react/react.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"React",permalink:"/docusaurus-documentation/id/docs/category/react"},next:{title:"Redux",permalink:"/docusaurus-documentation/id/docs/redux"}},d={},o=[{value:"Daftar Konten",id:"daftar-konten",level:2},{value:"1. Pengenalan React",id:"1-pengenalan-react",level:2},{value:"2. Setup Project",id:"2-setup-project",level:2},{value:"3. Component dan Props",id:"3-component-dan-props",level:2},{value:"4. Atomic Design dalam React JS",id:"4-atomic-design-dalam-react-js",level:2},{value:"5. React Router",id:"5-react-router",level:2},{value:"6. Conditional rendering",id:"6-conditional-rendering",level:2},{value:"7. Nested Component",id:"7-nested-component",level:2},{value:"8. Rendering List",id:"8-rendering-list",level:2},{value:"9.Event Handling",id:"9event-handling",level:2},{value:"10. State",id:"10-state",level:2},{value:"11. useState",id:"11-usestate",level:2},{value:"12. Lifecycle",id:"12-lifecycle",level:2},{value:"13. useEffect",id:"13-useeffect",level:2},{value:"14. useRef",id:"14-useref",level:2},{value:"15. Custom Hook",id:"15-custom-hook",level:2},{value:"16. Dynamic Routes",id:"16-dynamic-routes",level:2},{value:"17. Redux - state management",id:"17-redux---state-management",level:2},{value:"18. Redux Toolkit",id:"18-redux-toolkit",level:2},{value:"19. useContext",id:"19-usecontext",level:2},{value:"20. useReducer",id:"20-usereducer",level:2}];function c(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components},{Details:a}=e;return a||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"belajar-react",children:"Belajar React"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/TomiSaputraa/ReactJs-Learning",children:"Link Github"})}),"\n",(0,r.jsx)(e.h2,{id:"daftar-konten",children:"Daftar Konten"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"#belajar-react",children:"Belajar React"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Daftar Konten"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#1-pengenalan-react",children:"1. Pengenalan React"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#2-setup-project",children:"2. Setup Project"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#3-component-dan-props",children:"3. Component dan Props"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#4-atomic-design-dalam-react-js",children:"4. Atomic Design dalam React JS"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#5-react-router",children:"5. React Router"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#6-conditional-rendering",children:"6. Conditional rendering"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#7-nested-component",children:"7. Nested Component"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#8-rendering-list",children:"8. Rendering List"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#9event-handling",children:"9.Event Handling"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#10-state",children:"10. State"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#11-usestate",children:"11. useState"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#12-lifecycle",children:"12. Lifecycle"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#13-useeffect",children:"13. useEffect"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#14-useref",children:"14. useRef"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#15-custom-hook",children:"15. Custom Hook"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#16-dynamic-routes",children:"16. Dynamic Routes"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#17-redux---state-management",children:"17. Redux - state management"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#18-redux-toolkit",children:"18. Redux Toolkit"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#19-usecontext",children:"19. useContext"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"#20-usereducer",children:"20. useReducer"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"1-pengenalan-react",children:"1. Pengenalan React"}),"\n",(0,r.jsx)(e.p,{children:"React pertama kali dikembangkan oleh Jordan Walke pada tahun 2011. Ide awal React muncul dari kebutuhan Facebook untuk membangun antarmuka pengguna yang lebih cepat dan efisien. Jordan Walke terinspirasi oleh XHP, sebuah framework untuk komponen berbasis HTML di PHP yang digunakan di Facebook."}),"\n",(0,r.jsx)(e.p,{children:"Lalu tahun 2013 Facebook secara resmi memperkenalkan React pada konferensi JSConf US."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Apa itu React?"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"React adalah pustaka (library) JavaScript yang digunakan untuk membangun antarmuka pengguna (UI) yang dinamis dan interaktif."}),"\n",(0,r.jsx)(e.li,{children:"Komponen adalah blok bangunan utama dari aplikasi React. Komponen memungkinkan pengembang untuk memecah UI menjadi bagian-bagian kecil yang dapat digunakan kembali."}),"\n",(0,r.jsx)(e.li,{children:"Virtual DOM adalah salah satu fitur utama dari React. Virtual DOM adalah representasi ringan dari DOM asli. React menggunakan Virtual DOM untuk meminimalkan manipulasi DOM langsung, sehingga meningkatkan performa aplikasi."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Mengapa Menggunakan React?"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Komponen yang dapat digunakan kembali: Komponen React memungkinkan Anda untuk memecah UI menjadi bagian-bagian kecil yang dapat digunakan kembali, sehingga memudahkan pengembangan dan pemeliharaan aplikasi."}),"\n"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Virtual DOM: React menggunakan Virtual DOM untuk meningkatkan performa aplikasi dengan meminimalkan manipulasi DOM langsung."}),"\n",(0,r.jsx)(e.li,{children:"Deklaratif: React menggunakan pendekatan deklaratif untuk mendesain UI, yang membuat kode lebih mudah dibaca dan dipahami."}),"\n",(0,r.jsx)(e.li,{children:"Komunitas yang besar: React memiliki komunitas yang besar dan aktif, sehingga banyak sumber daya dan pustaka pihak ketiga yang tersedia."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"2-setup-project",children:"2. Setup Project"}),"\n",(0,r.jsx)(e.p,{children:"Setup awal bisa menggunakan create-react-app atau menggunakan front end tooling vite :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"yarn create vite\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://vitejs.dev/guide/",children:"https://vitejs.dev/guide/"})}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"atau jika ingin menggunakan css frameworks :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"yarn add -D tailwindcss postcss autoprefixer\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://tailwindcss.com/docs/guides/vite",children:"https://tailwindcss.com/docs/guides/vite"})}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"gunakan prettier untuk Tailwind dengan cara :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"yarn add prettier\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"yarn add -D prettier-plugin-tailwindcss\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://tailwindcss.com/blog/automatic-class-sorting-with-prettier",children:"Dok setup disini"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"yarn add --save-dev eslint-plugin-prettier eslint-config-prettier\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["lalu ubah file ",(0,r.jsx)(e.code,{children:".eslintr.cjs"})," :","\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"extends: [\r\n'plugin:prettier/recommended',\r\n// 'eslint:recommended',\r\n],\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["untuk format tailwind jalankan di terminal :","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"npx prettier -w --no-config <file name>"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Done setiap kali format default akan menggunakan prettier"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"3-component-dan-props",children:"3. Component dan Props"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:'Component\r\nComponent adalah blok bangunan utama dalam aplikasi React. Komponen memungkinkan pengembang untuk membagi UI menjadi bagian-bagian kecil yang mandiri dan dapat digunakan kembali.\r\nSetiap komponen pada dasarnya adalah fungsi atau kelas JavaScript yang dapat menerima input (disebut "props") dan mengembalikan elemen React yang menggambarkan apa yang seharusnya muncul di layar'}),"\n",(0,r.jsx)(e.p,{children:"Contoh functional component dan class component :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// functional comp\r\nfunction Greeting(props) {\r\n  return <h1>Hello, {props.name}!</h1>;\r\n}\r\n\r\n// class component\r\nclass Greeting extends React.Component {\r\n  render() {\r\n    return <h1>Hello, {this.props.name}!</h1>;\r\n  }\r\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:'Props\r\nProps (singkatan dari "properties") adalah cara untuk mengirim data dari satu komponen ke komponen lain, terutama dari komponen induk ke komponen anak. Props bersifat read-only dan tidak dapat diubah oleh komponen penerima. Props membantu membuat komponen lebih dinamis dan dapat digunakan kembali.'}),"\n",(0,r.jsx)(e.p,{children:"Contoh props :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// function component\r\nfunction Greeting(props) {\r\n  return <h1>Hello, {props.name}!</h1>;\r\n}\r\n\r\n// class component\r\nclass Greeting extends React.Component {\r\n  render() {\r\n    return <h1>Hello, {this.props.name}!</h1>;\r\n  }\r\n}\r\n\r\n// penerima props\r\nfunction App() {\r\n  return <Greeting name="Alice" />;\r\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.code,{children:"Note : Komponen anak menerima props sebagai argumen (untuk komponen fungsional) atau melalui this.props (untuk komponen kelas)."})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"4-atomic-design-dalam-react-js",children:"4. Atomic Design dalam React JS"}),"\n",(0,r.jsx)(e.p,{children:"Atomic Design adalah metodologi yang terdiri dari lima tahap berbeda yang bekerja sama untuk menciptakan sistem desain antarmuka dengan cara yang lebih terencana dan hierarkis. Kelima tahap Atomic Design adalah:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Atoms"}),"\n",(0,r.jsx)(e.li,{children:"Molecules"}),"\n",(0,r.jsx)(e.li,{children:"Organism"}),"\n",(0,r.jsx)(e.li,{children:"Templates"}),"\n",(0,r.jsx)(e.li,{children:"Pages"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Berikut adalah gambaran sederhana Atomic Design yang dari pecahan kecil menjadi sebuah pages:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.code,{children:"Atoms->Molecules->Organisms->Templates->Pages"})}),"\n",(0,r.jsx)(e.p,{children:"Contoh penerapan Atomic Design dalam Project React JS ini"}),"\n",(0,r.jsx)(e.p,{children:"Folder :"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Elements/"})," : berperan sebagai Atoms dan Moleculs sesuai dengan elemen yang akan digunakan."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fragments/"})," : berperan sebagai Organisms adalah kombinasi dari ",(0,r.jsx)(e.strong,{children:"moleculs"})," dan ",(0,r.jsx)(e.strong,{children:"atoms"})," yang bekerja bersama untuk membentuk bagian yang lebih kompleks dari antarmuka pengguna."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Layouts/"})," : berperan sebagai Templates adalah tata letak halaman yang terdiri dari ",(0,r.jsx)(e.strong,{children:"organisms"})," yang disusun dalam struktur tertentu."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"../Pages/"})," : berperan sebagai Pages adalah implementasi akhir dari antarmuka pengguna yang menggabungkan semua komponen dari ",(0,r.jsx)(e.strong,{children:"atoms"}),", ",(0,r.jsx)(e.strong,{children:"moleculs"}),", ",(0,r.jsx)(e.strong,{children:"organisms"}),", dan ",(0,r.jsx)(e.strong,{children:"templates"}),", diisi dengan data aktual untuk membentuk antarmuka yang lengkap dan berfungsi."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"5-react-router",children:"5. React Router"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"React Router"})," adalah pustaka standar untuk mengelola navigasi dan routing dalam aplikasi React. Ini memungkinkan pengembang untuk membangun aplikasi web dengan navigasi dinamis, membuat aplikasi React yang lebih interaktif dan dengan berbagai halaman."]}),"\n",(0,r.jsxs)(e.p,{children:["######## Komponen Utama\r\n",(0,r.jsx)(e.code,{children:"BrowserRouter"}),":"]}),"\n",(0,r.jsx)(e.p,{children:"Pembungkus utama yang menggunakan HTML5 history API untuk menjaga sinkronisasi UI dengan URL."}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Route"}),":"]}),"\n",(0,r.jsx)(e.p,{children:"Mendefinisikan hubungan antara URL dan komponen yang akan dirender. Setiap Route memiliki path dan component."}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Switch"}),":"]}),"\n",(0,r.jsx)(e.p,{children:"Merender hanya satu Route yang cocok dengan URL saat ini, mencegah rendering beberapa rute sekaligus."}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Link"}),":"]}),"\n",(0,r.jsx)(e.p,{children:"Komponen yang digunakan untuk membuat navigasi antar halaman tanpa me-refresh halama"}),"\n",(0,r.jsxs)(e.p,{children:["Dokumentasi react router : ",(0,r.jsx)(e.a,{href:"https://reactrouter.com/en/main",children:"https://reactrouter.com/en/main"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"6-conditional-rendering",children:"6. Conditional rendering"}),"\n",(0,r.jsx)(e.p,{children:"Conditional rendering adalah teknik dalam React untuk merender komponen atau elemen tertentu berdasarkan kondisi tertentu. Ini memungkinkan pengembang untuk membuat UI yang dinamis dan responsif dengan menampilkan atau menyembunyikan elemen berdasarkan state atau props."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Menggunakan If-Else dalam JSX"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Metode ini menggunakan ekspresi JavaScript biasa untuk menentukan elemen mana yang akan dirender."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function Greeting(props) {\r\n  const isLoggedIn = props.isLoggedIn;\r\n  if (isLoggedIn) {\r\n    return <h1>Welcome back!</h1>;\r\n  } else {\r\n    return <h1>Please sign in.</h1>;\r\n  }\r\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Menggunakan Ternary Operator"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Ternary operator (condition ? true : false) adalah cara yang lebih ringkas untuk melakukan conditional rendering dalam JSX."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function Greeting(props) {\r\n  return (\r\n    <div>\r\n      {props.isLoggedIn ? <h1>Welcome back!</h1> : <h1>Please sign in.</h1>}\r\n    </div>\r\n  );\r\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Menggunakan Logical && Operator\r\nLogical AND (&&) dapat digunakan untuk merender elemen berdasarkan kondisi yang benar."}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function Mailbox(props) {\r\n  const unreadMessages = props.unreadMessages;\r\n  return (\r\n    <div>\r\n      <h1>Hello!</h1>\r\n      {unreadMessages.length > 0 && (\r\n        <h2>You have {unreadMessages.length} unread messages.</h2>\r\n      )}\r\n    </div>\r\n  );\r\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Conditional Rendering dengan Komponen"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Anda bisa memecah kondisi ke dalam komponen terpisah untuk membuat kode lebih bersih dan modular."}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsx)("summary",{children:"Click to expand!"}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function LoginButton(props) {\r\nreturn <button onClick={props.onClick}>Login</button>;\r\n}\r\n\r\nfunction LogoutButton(props) {\r\nreturn <button onClick={props.onClick}>Logout</button>;\r\n}\r\n\r\nclass LoginControl extends React.Component {\r\nconstructor(props) {\r\nsuper(props);\r\nthis.handleLoginClick = this.handleLoginClick.bind(this);\r\nthis.handleLogoutClick = this.handleLogoutClick.bind(this);\r\nthis.state = {isLoggedIn: false};\r\n}\r\n\r\nhandleLoginClick() {\r\nthis.setState({isLoggedIn: true});\r\n}\r\n\r\nhandleLogoutClick() {\r\nthis.setState({isLoggedIn: false});\r\n}\r\n\r\nrender() {\r\nconst isLoggedIn = this.state.isLoggedIn;\r\nlet button;\r\n\r\n  if (isLoggedIn) {\r\n    button = <LogoutButton onClick={this.handleLogoutClick} />;\r\n  } else {\r\n    button = <LoginButton onClick={this.handleLoginClick} />;\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <Greeting isLoggedIn={isLoggedIn} />\r\n      {button}\r\n    </div>\r\n  );\r\n\r\n}\r\n}\r\n\n"})})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"7-nested-component",children:"7. Nested Component"}),"\n",(0,r.jsx)(e.p,{children:"Komponen bersarang (nested components) dalam React adalah cara yang baik untuk membuat aplikasi Anda lebih modular, reusable, dan terstruktur dengan baik. Dengan membuat komponen yang lebih kecil dan kemudian menyusunnya bersama-sama, Anda dapat mengelola kompleksitas aplikasi yang lebih besar secara lebih efektif."}),"\n",(0,r.jsx)(e.p,{children:"cara menggunakan komponen bersarang dalam React:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Buat Komponen Anak (Child Components)"}),"\n",(0,r.jsx)(e.li,{children:"Buat Komponen Induk (Parent Component)"}),"\n",(0,r.jsx)(e.li,{children:"Aplikasi Utama"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"8-rendering-list",children:"8. Rendering List"}),"\n",(0,r.jsx)(e.p,{children:"Rendering daftar (list) dalam React adalah operasi umum yang sering dilakukan ketika Anda memiliki data dinamis yang ingin ditampilkan. React memberikan cara yang efisien untuk merender daftar menggunakan metode array seperti map()."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"Langkah-langkah untuk Merender Daftar dalam React"})}),"\n"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Siapkan Data: Data yang akan dirender biasanya dalam bentuk array."}),"\n",(0,r.jsx)(e.li,{children:"Gunakan map() untuk Iterasi: Gunakan metode map() untuk mengiterasi data dan mengembalikan elemen React."}),"\n",(0,r.jsx)(e.li,{children:"Tambahkan Key: Setiap elemen dalam daftar harus memiliki properti key yang unik untuk membantu React mengidentifikasi elemen yang berubah"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"9event-handling",children:"9.Event Handling"}),"\n",(0,r.jsx)(e.p,{children:"Event handling dalam React mirip dengan penanganan event di DOM, tetapi dengan beberapa perbedaan utama dalam sintaks dan pendekatan. Dalam React, Anda bekerja dengan elemen JSX, dan event handler ditambahkan sebagai atribut pada elemen-elemen tersebut."}),"\n",(0,r.jsx)(e.p,{children:"contoh sederhana :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const App = () => {\r\nconst handleClick = () => {\r\n  alert('Button clicked!');\r\n};\r\n\r\nreturn (\r\n  <div>\r\n    <h1>Event Handling in React</h1>\r\n    <button onClick={handleClick}>Click Me</button>\r\n  </div>\r\n);\r\n};\r\n\r\nexport default App;\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"10-state",children:"10. State"}),"\n",(0,r.jsx)(e.p,{children:"Dalam React, state adalah objek yang digunakan untuk menyimpan dan mengelola data yang dapat berubah sepanjang siklus hidup komponen. State memungkinkan komponen untuk merespons perubahan data dan merender ulang UI secara dinamis berdasarkan perubahan tersebut."}),"\n",(0,r.jsx)(e.p,{children:"Sejak React 16.8, React memperkenalkan hooks yang memungkinkan penggunaan state dalam komponen fungsional. Hook yang paling umum digunakan untuk state adalah useState."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"stateless"}),"\n",(0,r.jsx)(e.p,{children:"Stateless components, juga dikenal sebagai functional components, tidak memiliki state internal. Mereka hanya menerima props dan merender UI berdasarkan props tersebut. Mereka lebih sederhana dan lebih mudah diuji karena tidak memiliki logika state."}),"\n",(0,r.jsx)(e.p,{children:"contoh:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React from "react";\r\n\r\nconst Greeting = ({ name }) => {\r\n  return <h1>Hello, {name}!</h1>;\r\n};\r\n\r\nexport default Greeting;\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"stateful"}),"\n",(0,r.jsx)(e.p,{children:"Stateful components mengelola state internal mereka sendiri. Mereka dapat merespons perubahan state dan merender ulang UI berdasarkan state tersebut. Komponen ini lebih kompleks daripada komponen stateless karena mereka harus mengelola dan memperbarui state."}),"\n",(0,r.jsx)(e.p,{children:"contoh:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React, { useState } from "react";\r\n\r\nconst Counter = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  const increment = () => {\r\n    setCount(count + 1);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>Counter: {count}</h1>\r\n      <button onClick={increment}>Increment</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Counter;\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"11-usestate",children:"11. useState"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"useState"})," adalah salah satu hook yang diperkenalkan dalam React 16.8 yang memungkinkan Anda untuk menambahkan state ke dalam komponen fungsional. Dengan menggunakan useState, Anda bisa membuat komponen fungsional yang stateful. Berikut adalah penjelasan rinci tentang cara menggunakan useState dalam React."]}),"\n",(0,r.jsx)(e.p,{children:"sintaks dasar :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const [state, setState] = useState(initialState);\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"state: Nilai state saat ini."}),"\n",(0,r.jsx)(e.li,{children:"setState: Fungsi yang digunakan untuk memperbarui nilai state."}),"\n",(0,r.jsx)(e.li,{children:"initialState: Nilai awal dari state."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"contoh sederhana :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React, { useState } from "react";\r\n\r\nconst Counter = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  const increment = () => {\r\n    setCount(count + 1);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>Counter: {count}</h1>\r\n      <button onClick={increment}>Increment</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Counter;\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"12-lifecycle",children:"12. Lifecycle"}),"\n",(0,r.jsxs)(e.p,{children:["Lifecycle dalam React mengacu pada serangkaian metode yang dijalankan pada tahap-tahap tertentu dalam siklus hidup sebuah komponen. Dalam komponen berbasis class, lifecycle methods sering digunakan untuk mengatur komponen pada saat mount, update, dan unmount. Namun, dengan munculnya hooks di React versi 16.8, functional components bisa mencapai hal yang sama menggunakan ",(0,r.jsx)(e.code,{children:"useEffect"})," dan hooks lainnya."]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Class Component Lifecycle"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Mounting"})," (Ketika Komponen Pertama Kali Dipasang ke DOM)"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"constructor() : Dipanggil pertama kali ketika komponen dibuat. Biasanya digunakan untuk menginisialisasi state atau mengikat event handler."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:"render() : Metode ini wajib dan bertanggung jawab untuk mengembalikan JSX yang akan dirender ke DOM."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:"componentDidMount(): Dipanggil segera setelah komponen dimount ke DOM. Biasanya digunakan untuk melakukan fetch data atau menginisialisasi library pihak ketiga."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Updating"})," (Ketika Komponen Menerima Props Baru atau State Berubah)"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"shouldComponentUpdate(nextProps, nextState) : Digunakan untuk menentukan apakah komponen harus di-render ulang. Mengembalikan true atau false."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:"render() : sama seperti di mounting"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:"componentDidUpdate(prevProps, prevState, snapshot) : Dipanggil setelah komponen diperbarui di DOM."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Unmounting"})," (Ketika Komponen Dilepas dari DOM)"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"componentWillUnmount() : Dipanggil sebelum komponen dilepas dari DOM. Biasanya digunakan untuk membersihkan resource seperti timer atau event listener."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["Web contoh lifecycle react : ",(0,r.jsx)(e.a,{href:"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",children:"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"13-useeffect",children:"13. useEffect"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"useEffect"})," adalah hook di React yang memungkinkan Anda menjalankan efek samping dalam komponen fungsional. Efek samping ini dapat mencakup pengambilan data, manipulasi DOM, pengaturan timer, dan banyak lagi. ",(0,r.jsx)(e.code,{children:"useEffect"})," menggantikan lifecycle methods seperti ",(0,r.jsx)(e.code,{children:"componentDidMount"}),", ",(0,r.jsx)(e.code,{children:"componentDidUpdate"}),", dan ",(0,r.jsx)(e.code,{children:"componentWillUnmount"})," dalam komponen berbasis class."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Sintaks"})," :"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"useEffect(() => {\r\n  // code untuk efek samping di sini\r\n\r\n  return () => {\r\n    // code untuk cleanup (pembersihan) di sini\r\n  };\r\n}, [dependencies]);\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Callback function: Fungsi yang akan dijalankan setelah render. Fungsi ini bisa mengembalikan fungsi cleanup untuk membersihkan resource."}),"\n",(0,r.jsxs)(e.li,{children:["Dependencies array: Array dari nilai-nilai yang dipantau oleh ",(0,r.jsx)(e.code,{children:"useEffect"}),". Efek akan dijalankan ulang jika salah satu dari nilai-nilai ini berubah."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Penjelasan Lebih Lanjut:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Efek Tanpa Dependencies: Jika Anda tidak menyertakan array dependencies, efek akan dijalankan setelah setiap render.\r\nEfek dengan Array Dependencies Kosong:"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Jika Anda memberikan array dependencies kosong [], efek hanya akan dijalankan sekali setelah komponen dimount dan pembersihan dilakukan ketika komponen diunmount.\r\nEfek dengan Dependencies:"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Efek hanya akan dijalankan ulang jika ada perubahan pada salah satu nilai dalam array dependencies. Hal ini membuat ",(0,r.jsx)(e.code,{children:"useEffect"})," sangat efisien karena tidak menjalankan efek secara berulang kali tanpa kebutuhan.\r\nCleanup Function:"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Jika efek Anda menghasilkan efek samping yang perlu dibersihkan (misalnya, langganan ke event atau timer), Anda dapat mengembalikan fungsi pembersihan dari callback function di ",(0,r.jsx)(e.code,{children:"useEffect"}),". Fungsi ini akan dipanggil sebelum efek dijalankan lagi dan sebelum komponen diunmount."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Contoh Implementasi dalam Functional Component"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React, { useState, useEffect } from "react";\r\n\r\nfunction DataFetchingComponent() {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  useEffect(() => {\r\n    // Fetch data from API\r\n    fetch("https://api.example.com/data")\r\n      .then((response) => response.json())\r\n      .then((data) => {\r\n        setData(data);\r\n        setLoading(false);\r\n      })\r\n      .catch((error) => {\r\n        console.error("Error fetching data:", error);\r\n        setLoading(false);\r\n      });\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      console.log("Cleanup code here");\r\n    };\r\n  }, []); // Only run once after initial render\r\n\r\n  if (loading) {\r\n    return <p>Loading...</p>;\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <h1>Fetched Data:</h1>\r\n      <pre>{JSON.stringify(data, null, 2)}</pre>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default DataFetchingComponent;\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"14-useref",children:"14. useRef"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"useRef"})," adalah salah satu hook di React yang memungkinkan Anda untuk membuat referensi yang persisten terhadap elemen DOM atau nilai yang tidak memicu render ulang ketika berubah. Ini sangat berguna untuk mengakses elemen DOM langsung, menyimpan nilai yang tidak mempengaruhi rendering, atau menjaga referensi terhadap komponen yang tidak memerlukan render ulang."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Cara Menggunakan useRef"})," :"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Mengakses Elemen DOM"}),"\n",(0,r.jsxs)(e.p,{children:["Anda dapat menggunakan ",(0,r.jsx)(e.code,{children:"useRef"})," untuk mendapatkan referensi langsung ke elemen DOM yang kemudian bisa Anda manipulasi atau akses properti DOM-nya."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React, { useRef, useEffect } from "react";\r\n\r\nfunction FocusInput() {\r\n  const inputRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    // Fokus pada input saat komponen pertama kali dimount\r\n    inputRef.current.focus();\r\n  }, []);\r\n\r\n  return <input ref={inputRef} type="text" />;\r\n}\r\n\r\nexport default FocusInput;\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Menyimpan Nilai yang Tidak Memicu Render Ulang"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"useRef"})," dapat digunakan untuk menyimpan nilai yang berubah, tetapi tidak menyebabkan komponen di-render ulang ketika nilai tersebut berubah."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React, { useRef, useState } from "react";\r\n\r\nfunction Stopwatch() {\r\n  const timerIdRef = useRef(null);\r\n  const [count, setCount] = useState(0);\r\n\r\n  const startTimer = () => {\r\n    timerIdRef.current = setInterval(() => {\r\n      setCount((prevCount) => prevCount + 1);\r\n    }, 1000);\r\n  };\r\n\r\n  const stopTimer = () => {\r\n    clearInterval(timerIdRef.current);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>Timer: {count}</p>\r\n      <button onClick={startTimer}>Start</button>\r\n      <button onClick={stopTimer}>Stop</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Stopwatch;\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Menggunakan useRef untuk Menyimpan Nilai Sebelumnya"}),"\n",(0,r.jsx)(e.p,{children:"Anda juga dapat menggunakan useRef untuk menyimpan nilai sebelumnya dari suatu state atau prop."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React, { useRef, useEffect, useState } from "react";\r\n\r\nfunction PreviousValue() {\r\n  const [count, setCount] = useState(0);\r\n  const prevCountRef = useRef();\r\n\r\n  useEffect(() => {\r\n    prevCountRef.current = count;\r\n  }, [count]);\r\n\r\n  const prevCount = prevCountRef.current;\r\n\r\n  return (\r\n    <div>\r\n      <p>Current count: {count}</p>\r\n      <p>Previous count: {prevCount}</p>\r\n      <button onClick={() => setCount(count + 1)}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default PreviousValue;\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Rangkuman Kegunaan useRef"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mengakses Elemen DOM"}),": Untuk mendapatkan referensi ke elemen DOM secara langsung dan memanipulasinya."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Menyimpan Nilai yang Persisten"}),": Untuk menyimpan nilai yang tidak mempengaruhi rendering komponen."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Menjaga Referensi Nilai Sebelumnya"}),": Untuk menyimpan nilai sebelumnya dari state atau props."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"15-custom-hook",children:"15. Custom Hook"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Custom hooks"})," di React adalah fungsi JavaScript yang memungkinkan Anda untuk mengekstrak logika yang dapat digunakan kembali dari komponen fungsional. Mereka dimulai dengan use dan dapat memanfaatkan hook React lainnya, seperti ",(0,r.jsx)(e.code,{children:"useState"}),", ",(0,r.jsx)(e.code,{children:"useEffect"}),", ",(0,r.jsx)(e.code,{children:"useContext"}),", dll. Dengan custom hooks, Anda dapat membuat kode yang lebih modular dan mudah dikelola."]}),"\n",(0,r.jsx)(e.p,{children:"contoh :"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Custom Hook untuk Mengambil Data (useFetch)"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import { useState, useEffect } from "react";\r\n\r\nfunction useFetch(url) {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      try {\r\n        const response = await fetch(url);\r\n        if (!response.ok) {\r\n          throw new Error("Network response was not ok");\r\n        }\r\n        const result = await response.json();\r\n        setData(result);\r\n      } catch (error) {\r\n        setError(error);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n  }, [url]);\r\n\r\n  return { data, loading, error };\r\n}\r\n\r\nexport default useFetch;\n'})}),"\n",(0,r.jsx)(e.p,{children:"Penggunaan useFetch di komponen:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React from "react";\r\nimport useFetch from "./useFetch";\r\n\r\nfunction App() {\r\n  const { data, loading, error } = useFetch("https://api.example.com/data");\r\n\r\n  if (loading) return <p>Loading...</p>;\r\n  if (error) return <p>Error: {error.message}</p>;\r\n\r\n  return (\r\n    <div>\r\n      <h1>Data:</h1>\r\n      <pre>{JSON.stringify(data, null, 2)}</pre>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\n'})}),"\n",(0,r.jsx)(e.p,{children:"Prinsip-Prinsip Custom Hook :"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Prefix use:"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Semua custom hook harus diawali dengan use untuk memastikan mereka mengikuti konvensi hook dan agar React dapat mendeteksi pelanggaran aturan hook."}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:"Menggunakan Hook Lain:"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Custom hook dapat menggunakan hook React lainnya seperti useState, useEffect, useContext, dll. untuk mengelola logika kompleks."}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:"Pemisahan Logika dan UI:"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Custom hook memungkinkan Anda untuk memisahkan logika stateful dari presentasi, membuat kode lebih modular dan dapat digunakan kembali."}),"\n",(0,r.jsxs)(e.ol,{start:"4",children:["\n",(0,r.jsx)(e.li,{children:"Tidak Merupakan Komponen React:"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Custom hook bukanlah komponen React dan tidak memiliki lifecycle sendiri, tetapi dapat menggunakan lifecycle dari hook seperti useEffect."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"16-dynamic-routes",children:"16. Dynamic Routes"}),"\n",(0,r.jsx)(e.p,{children:"Dalam React, dynamic routes memungkinkan Anda untuk membuat rute yang dapat menangani URL dengan parameter variabel. Ini sangat berguna untuk membuat aplikasi yang membutuhkan navigasi berdasarkan konten dinamis, seperti profil pengguna, artikel blog, atau halaman produk. Library seperti React Router menyediakan fitur ini dengan cara yang efisien."}),"\n",(0,r.jsxs)(e.p,{children:["perlu package : ",(0,r.jsx)(e.code,{children:"yarn add react-router-dom"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Ringkasan"})," :"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"BrowserRouter"}),": Mengelola routing di aplikasi Anda.\r\n",(0,r.jsx)(e.code,{children:"Routes dan Route"}),": Menentukan rute aplikasi Anda, termasuk rute dinamis.\r\n",(0,r.jsx)(e.code,{children:"useParams"}),": Mengakses parameter rute dinamis dalam komponen Anda.\r\n",(0,r.jsx)(e.code,{children:"Link"}),": Membuat tautan navigasi ke rute dinamis."]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"17-redux---state-management",children:"17. Redux - state management"}),"\n",(0,r.jsx)(e.p,{children:"Redux adalah pustaka manajemen state yang sering digunakan dengan React untuk membantu mengelola state aplikasi yang kompleks. Redux menyediakan cara yang terstruktur untuk mengelola state global di aplikasi React, memungkinkan Anda untuk lebih mudah melacak, debug, dan memelihara state."}),"\n",(0,r.jsx)(e.p,{children:"Konsep Utama dalam Redux"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Store: Tempat penyimpanan state aplikasi. Hanya ada satu store untuk setiap aplikasi Redux."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Action: Objek yang menggambarkan perubahan yang ingin Anda lakukan terhadap state. Action harus memiliki properti type dan dapat memiliki data tambahan."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Reducer: Fungsi murni yang menentukan bagaimana state berubah sebagai respons terhadap action. Reducer menerima state saat ini dan action, kemudian mengembalikan state baru."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Dispatch: Metode untuk mengirimkan action ke store untuk memicu perubahan state."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Selector: Fungsi untuk mengekstrak data dari state store."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://redux.js.org/introduction/getting-started",children:"Dokumentasi Redux"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"18-redux-toolkit",children:"18. Redux Toolkit"}),"\n",(0,r.jsx)(e.p,{children:"Redux Toolkit adalah toolkit resmi dari tim Redux yang membantu dalam membuat aplikasi Redux dengan cara yang lebih efisien dan lebih sedikit boilerplate. Redux Toolkit menyediakan beberapa utilitas yang memudahkan pembuatan store, reducer, dan actions dengan cara yang lebih deklaratif dan tersentralisasi."}),"\n",(0,r.jsx)(e.p,{children:"installasi :"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"npm install @reduxjs/toolkit react-redux\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Membuat Slice dengan Redux Toolkit"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:'Redux Toolkit memperkenalkan konsep "slice" yang menggabungkan actions dan reducers dalam satu tempat.'}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mengonfigurasi Store"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Gunakan configureStore dari Redux Toolkit untuk membuat store."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Menghubungkan Store ke Aplikasi React"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Gunakan Provider dari react-redux untuk membuat store tersedia bagi komponen React."}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Ringkasan"})," :"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Membuat Slice"}),": Menggunakan createSlice untuk membuat reducer dan actions dalam satu tempat."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Membuat Store"}),": Menggunakan configureStore untuk menggabungkan semua reducer."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Menghubungkan Store ke Aplikasi React"}),": Menggunakan Provider dari react-redux."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mengakses State dan Mengirimkan Actions"}),": Menggunakan useSelector dan useDispatch dari react-redux."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://redux-toolkit.js.org/introduction/getting-started",children:"Dokumentasi Redux toolkit"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"19-usecontext",children:"19. useContext"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"useContext"})," adalah hook di React yang memungkinkan Anda untuk mengonsumsi konteks dalam komponen fungsional. Konteks menyediakan cara untuk meneruskan data melalui pohon komponen (komponen tree) tanpa harus secara eksplisit meneruskan prop ke setiap level. Hal ini sangat berguna untuk data global seperti tema, autentikasi, atau pengaturan aplikasi."]}),"\n",(0,r.jsx)(e.p,{children:"Langkah-langkah Menggunakan useContext"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Membuat Konteks"}),"\n",(0,r.jsx)(e.li,{children:"Menyediakan Konteks"}),"\n",(0,r.jsx)(e.li,{children:"Mengonsumsi Konteks"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Manfaat useContext"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mengurangi Prop Drilling: Menghindari keharusan meneruskan prop melalui banyak level komponen."}),"\n",(0,r.jsx)(e.li,{children:"Data Global: Sangat berguna untuk data yang harus diakses oleh banyak komponen di berbagai level."}),"\n",(0,r.jsx)(e.li,{children:"Peningkatan Keterbacaan: Kode menjadi lebih bersih dan mudah dibaca karena pengurangan prop drilling."}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})}),"\n",(0,r.jsx)(e.h2,{id:"20-usereducer",children:"20. useReducer"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"useReducer"})," adalah hook di React yang menawarkan pengelolaan state yang lebih kompleks dibandingkan dengan useState. useReducer sangat cocok untuk kasus di mana state memiliki logika yang rumit atau ketika ada banyak tindakan yang mengubah state."]}),"\n",(0,r.jsxs)(e.p,{children:["Struktur Dasar useReducer :\r\n",(0,r.jsx)(e.code,{children:"const [state, dispatch] = useReducer(reducer, initialState);"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"state"}),": Nilai state saat ini."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"dispatch"}),": Fungsi yang digunakan untuk mengirimkan aksi ke reducer."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"reducer"}),": Fungsi yang menentukan bagaimana state diubah berdasarkan aksi yang diterima."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"initialState"}),": Nilai awal dari state."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"#daftar-konten",children:"Back to top \ud83d\udd1d"})})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>s,x:()=>l});var r=a(6540);const i={},t=r.createContext(i);function s(n){const e=r.useContext(t);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);